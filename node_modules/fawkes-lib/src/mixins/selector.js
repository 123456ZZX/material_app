/*
 * @Author: wei_jt@ecidi.com
 * @Date: 2019-07-19 19:40:56
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-03-09 16:12:13
 * @Description: 选择组件通用部分
 */
export default {
  inject: {
    fksForm: {
      default() {
        return {};
      }
    },
    fksFormItem: {
      default() {
        return {};
      }
    }
  },
  props: {
    showAllUser: {
      type: Boolean,
      default: false
    },
    width: {
      type: String,
      default: '100%'
    },
    url: {
      type: String,
      default: ''
    },
    params: {
      type: Object,
      default() {
        return {};
      }
    },
    headers: {
      type: Object,
      default() {
        return {};
      }
    },
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    readonly: Boolean,
    disabled: Boolean,
    /** 标签是否收缩 */
    collapseTags: Boolean,
    size: String,
    related: {
      type: Object,
      default() {
        return {};
      }
    }
  },
  data() {
    return {
      initialInputHeight: 0,
      visible: false
    };
  },
  computed: {
    collapseTagSize() {
      return ['small', 'mini'].indexOf(this.size) > -1
        ? 'mini'
        : 'small';
    },
    forbidden() {
      return this.disabled || !!(this.fksForm && this.fksForm.disabled) || (((this.fksForm || {}).flowConfig || {})[(this.fksFormItem || {}).prop] ==
        'disabled');
    },
    uploadReadOnly() {
      return this.readonly || (
        ((this.fksForm || {}).flowConfig || {})[(this.fksFormItem || {}).prop] ==
        'readonly'
      );
    }
  },
  methods: {
    resetInputHeight() {
      this.$nextTick(() => {
        if (!this.$refs.input) return;
        let inputChildNodes = this.$refs.input.$el.childNodes;
        let input = [].filter.call(inputChildNodes, item => item.tagName === 'INPUT')[0];
        const tags = this.$refs.tags;
        const sizeInMap = this.initialInputHeight || 36;
        const list = this.sureList || this.chosedList;
        input.style.height = list.length === 0
          ? sizeInMap + 'px'
          : Math.max(
            tags ? (tags.clientHeight + (tags.clientHeight > sizeInMap ? 4 : 0)) : 0,
            sizeInMap
          ) + 'px';
      });
    }
  },
  watch: {
    collapseTags() {
      if (this.multiple) {
        this.resetInputHeight();
      }
    }
  },
  mounted() {
    const sizeMap = {
      large: 40,
      small: 32,
      mini: 28
    };
    this.initialInputHeight = sizeMap[this.size];
  }
};
