'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
  (typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.FocusOutside = {}));
})(undefined, function (exports) {
  'use strict';

  var Map = function () {
    function Map() {
      this.maps = [];
      this.size = 0;
    }
    Map.prototype.find = function (key) {
      for (var i = 0; i < this.maps.length; i++) {
        if (this.maps[i][0] === key) {
          return { index: i, value: this.maps[i][1], key: key };
        }
      }
    };
    Map.prototype.set = function (key, value) {
      var result = this.find(key);
      if (result) {
        this.maps[result.index][1] = value;
      } else {
        this.maps.push([key, value]);
        this.size++;
      }
      return this;
    };
    Map.prototype.get = function (key) {
      var result = this.find(key);
      return result && result.value;
    };
    Map.prototype.has = function (key) {
      if (this.find(key)) {
        return true;
      }
      return false;
    };
    Map.prototype.delete = function (key) {
      var result = this.find(key);
      if (!result) {
        return false;
      }
      this.maps.splice(result.index, 1);
      this.size--;
      return true;
    };
    Map.prototype.clear = function () {
      this.maps = [];
      this.size = 0;
    };
    Map.prototype.values = function () {
      return this.maps.map(function (item) {
        return item[1];
      });
    };
    Map.prototype.entries = function () {
      return this.maps;
    };
    return Map;
  }();

  var els = [];
  var elMap = new Map();
  function isNotFocusable(el) {
    return isNaN(parseInt(el.getAttribute('tabindex')));
  }
  function setFocusable(el) {
    el.setAttribute('tabindex', '-1');
  }
  function getNode(target) {
    return els.find(function (el) {
      return el.contains(target) || el === target;
    });
  }
  function addClass(el, name) {
    var classList = el.className.split(' ');
    if (classList.indexOf(name) > -1) {
      return;
    }
    classList.push(name);
    el.className = classList.join(' ');
  }
  function removeClass(el, name) {
    var classList = el.className.split(' ');
    var index = classList.indexOf(name);
    if (index < 0) {
      return;
    }
    classList.splice(index, 1);
    el.className = classList.join(' ');
  }
  function focusinHandler(event) {
    var node = getNode(event.target);
    if (!node) {
      return;
    }
    var _a = findNodeMap(elMap.entries(), node) || {},
        item = _a.item,
        nodeList = _a.nodeList;
    if (!item) {
      return;
    }
    // 判断目标是否包含在绑定元素中，如果包含在绑定元素中就清除定时器

    clearTimeout(nodeList.timerId);
    nodeList.timerId = null;
  }
  function focusoutHandler(event) {
    var node = getNode(event.target);

    if (!node) {
      return;
    }

    var _a = findNodeMap(elMap.entries(), node) || {},
        item = _a.item,
        nodeList = _a.nodeList;
    if (nodeList.timerId) {
      return;
    }
    if (!item) {
      return;
    }
    // callback-undefined问题避免
    // 设置长延时，clearTimeout后执行
    if (item.callback) {
      if (item.callback.value) {
        nodeList.timerId = setTimeout(function () {
          item.callback.value(event.target);
        }, 120);
      }
    }
  }
  function findNodeMap(entries, node) {
    for (var i = 0; i < entries.length; i++) {
      var _a = entries[i],
          key = _a[0],
          nodeList = _a[1];
      var item = nodeList.find(function (item) {
        return item.node === node;
      });
      if (item) {
        return { key: key, item: item, nodeList: nodeList };
      }
    }
  }

  function bind(el, callback, key, className) {
    if (className === void 0) {
      className = 'focus-outside';
    }
    if (!key) {
      key = callback;
    }
    // callback.defaultClass = className;
    if (els.indexOf(el) < 0) {
      els.push(el);
    }
    if (elMap.has(key)) {
      var nodeList = elMap.get(key);
      nodeList.push({
        node: el,
        callback: callback,
        oldTabIndex: el.getAttribute('tabindex')
      });
    } else {
      elMap.set(key, [{
        node: el,
        callback: callback,
        oldTabIndex: el.getAttribute('tabindex')
      }]);
    }
    if (isNotFocusable(el)) {
      setFocusable(el);
    }
    addClass(el, className);
    el.addEventListener('focusin', focusinHandler);
    el.addEventListener('focusout', focusoutHandler);
  }
  function unbind(el) {
    var _a = findNodeMap(elMap.entries(), el) || {},
        item = _a.item,
        key = _a.key,
        nodeList = _a.nodeList;
    if (!item) {
      return;
    }
    var node = item.node,
        callback = item.callback,
        oldTabIndex = item.oldTabIndex;
    var index = els.indexOf(node);
    if (index > -1) {
      els.splice(index, 1);
    }
    removeClass(node, callback.defaultClass);
    if (oldTabIndex) {
      node.setAttribute('tabindex', oldTabIndex);
    } else {
      node.removeAttribute('tabindex');
    }
    node.removeEventListener('focusin', focusinHandler);
    node.removeEventListener('focusout', focusoutHandler);
    var nodeIndex = nodeList.indexOf(item);
    if (index > -1) {
      nodeList.splice(nodeIndex, 1);
    }
    if (!nodeList.length) {
      elMap.delete(key);
    }
  }

  module.exports.bind = bind;
  module.exports.unbind = unbind;

  Object.defineProperty(exports, '__esModule', { value: true });
});